---
title: "Expression correlation analysis"
author: "Sara gosline"
date: "8/20/2021"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

require(remotes)
if(!require(mpnstXenoModeling)){
  remotes::install_github('sgosline/mpnstXenoModeling')
  library(mpnstXenoModeling)
}

if(!require('leapr')){
  remotes::install_github('biodataganache/leapR')
  library(leapr)
}

library(dplyr)

```

Here we bring in the RNASeq data and the `leapR` package to measure and identify correlated pathways across the samples.


## Load data from synapse query


```{r loadData,warning=FALSE,echo=FALSE}
#this function simply loads all the data into memory

syn<-reticulate::import('synapseclient')$login()
data.tab<-syn$tableQuery('select * from syn24215021')$asDataFrame()
rnaSeq<<-mpnstXenoModeling::dataFromSynTable(data.tab,syn,'RNASeq')%>%
  mutate(`Clinical Status`=gsub("NED","Alive",gsub('Alive with metastatic disease','Alive',Clinical.Status)))

```


## RNASeq DAta

We have now implemented DESeq2 column normalization to enable the visualization of RNASeq Data. Let's plot them, after normalization, via PCA to see how they cluster and group independently. Then we can interrogate the genes themselves.


```{r filtering, warning=FALSE}
library(DESeq2)

dds <-mpnstXenoModeling::deseq2NormFilter(rnaSeq)
  
vsd <- DESeq2::vst(dds)


```

### How do samples cluster?

We want to plot the variable genes in a heatmap and also the PCA


```{r Pca plot}
library(ggplot2)
pcaData <- plotPCA(vsd, intgroup=c("Sex", "Clinical Status"), returnData=TRUE)

percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=Sex, shape=`Clinical.Status`)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()+ggtitle('Samples by normalized expression')
```

### Heatmap of most variable

What genes are the most variable after normalization?

```{r most variable}
library(pheatmap)

pat.annote <- rnaSeq %>%
    dplyr::select(Sample, MicroTissueQuality, `Clinical Status`, Sex) %>%
    distinct()%>%
    mutate(MicroTissueQuality=unlist(MicroTissueQuality))%>%
  tibble::column_to_rownames('Sample')


keep <- which(rowMin(counts(dds,normalized=TRUE))>10)
pat.var <- apply(counts(dds[keep,],normalized=TRUE),1,var)%>%sort()

symbs<-names(pat.var)[1:100]

count.mat<-counts(dds,normalized=TRUE)#[symbs,]

library(pheatmap)
pheatmap(count.mat[symbs,],cellwidth = 10,cellheight=10,annotation_col = pat.annote,filename='mostVarTrans.pdf')
pheatmap(count.mat[symbs,],cellwidth = 10,cellheight=10,annotation_col = pat.annote)

```

## Correlate all genes across Samples

What pathways are enriched in correlation across these? Need to actually do this!!!

```{r leapr cor}

##now let's look at the pathways that are correlated across all
library(leapr)
#data(ncipid)
data("krbpaths")
idx.kegg <- grepl("^KEGG_", krbpaths$names)
names.kegg <- krbpaths$names[idx.kegg]
names.kegg <- sub("KEGG_", "", names.kegg)
names.kegg <- gsub("_", " ", names.kegg)
names.kegg <- sapply(names.kegg, function(y) paste(strwrap(y, 45), 
                                          collapse = "\n"), 
                     USE.NAMES = FALSE)
desc.kegg <- krbpaths$desc[idx.kegg]
sizes.kegg <- krbpaths$sizes[idx.kegg]
Max <- max(sizes.kegg)
matrix.kegg <- krbpaths$matrix[idx.kegg, 1:Max]
keggpaths <- list(names = names.kegg,
                 desc = desc.kegg,
                 sizes = sizes.kegg,
                 matrix = matrix.kegg)
#term.2.gene <- as.data.frame(keggpaths$matrix) %>%
#  mutate(term = keggpaths$names) %>%
#  pivot_longer(!term, names_to = "Column", values_to = "gene") %>%
#  filter(!(gene == "null")) %>%
#  select(term, gene)
#term.2.name <- data.frame(term = keggpaths$names, name = keggpaths$names)
  
#plotCorrelationEnrichment(as.matrix(data.mat), keggpaths, fdr.cutoff = 0.05, 
#                                      corr.cutoff = 0.1, prefix='allSamps', width = 11, 
#                                      height = 8.5, order.by = "Ingroup mean", 
#                                      clean.names = FALSE, pathway.plot.size = 3)


```
